// Generated by CoffeeScript 1.9.3
(function() {
  var assert, colors, fs, init, initProject, popular_modules, prompt, request, userHome, yaml;

  assert = require('assert');

  colors = require('colors');

  fs = require('fs');

  prompt = require('prompt');

  request = require('sync-request');

  userHome = require('user-home');

  yaml = require('js-yaml');

  popular_modules = [];

  initProject = function(crystal, opts, path) {
    var config, exp, exports, j, len, module_name;
    if (!opts.name) {
      throw new Error('Name is required.');
    }
    config = {};
    config.name = opts.name;
    if (opts.description) {
      config.description = opts.description;
    }
    config.author = {
      name: opts.author_name,
      email: opts.author_email,
      url: opts.author_url
    };
    config.copyright = opts.copyright;
    if (opts.modules) {
      config.modules = {};
      for (module_name in opts.modules) {
        exports = opts.modules[module_name];
        config.modules[module_name] = 'latest';
        if (exports.length) {
          config.imports = {};
          for (j = 0, len = exports.length; j < len; j++) {
            exp = exports[j];
            config.imports["" + exp] = module_name + "." + exp;
          }
        }
      }
    }
    config = yaml.safeDump(config);
    if (!fs.existsSync(path + "/.autocode")) {
      fs.mkdirSync(path + "/.autocode");
    }
    fs.writeFileSync(path + "/.autocode/config.yml", config);
    console.log('Autocode initialization is complete.'.green);
    return crystal.build(path);
  };

  init = function(opts) {
    var config, crystal, properties;
    crystal = this;
    opts.path = opts._[1] || opts.path || this.path || process.cwd();
    if (!opts.path) {
      throw new Error('Path is required.');
    } else if (!fs.existsSync(opts.path)) {
      throw new Error("Path does not exist: " + opts.path);
    }
    config = this.load(opts.path);
    if (config !== false) {
      throw new Error("Autocode has already been initialized in: " + opts.path);
    }
    console.log(("Initializing Autocode in: " + opts.path).green.bold);
    prompt.message = '';
    prompt.delimiter = '';
    prompt.start();
    if (opts.name && opts.name.length) {
      return initProject(opts, opts.path);
    } else {
      properties = {};
      if (!opts.name) {
        properties.name = {
          description: "Name (ex: Acme Website)",
          required: true,
          type: 'string'
        };
      }
      if (!opts.description) {
        properties.description = {
          description: "Description (ex: website for Acme, Inc.)",
          required: true,
          type: 'string'
        };
      }
      if (!opts.author_name) {
        properties.author_name = {
          description: "Author Name (ex: Author)",
          required: true,
          type: 'string'
        };
      }
      if (!opts.author_email) {
        properties.author_email = {
          description: "Author Email (ex: author@example.org)",
          required: true,
          type: 'string'
        };
      }
      if (!opts.author_url) {
        properties.author_url = {
          description: "Author URL (ex: http://example.org)",
          required: true,
          type: 'string'
        };
      }
      if (!opts.copyright) {
        properties.copyright = {
          description: "Copyright (ex: 2015 Acme, Inc.)",
          required: true,
          type: 'string'
        };
      }
      return prompt.get({
        properties: properties
      }, function(err, result) {
        var addImport, addModule, j, len, mod, modules, response;
        if (err) {
          return console.log("\nMaybe next time.");
        } else {
          result.name = opts.name || result.name;
          result.description = opts.description || result.description;
          result.author_name = opts.author_name || result.author_name;
          result.author_email = opts.author_email || result.author_email;
          result.author_url = opts.author_url || result.author_url;
          result.copyright = opts.copyright || result.copyright;
          initProject(crystal, result, opts.path);
          return;
          console.log("Loading popular modules...");
          response = request('get', crystal.url('api', 'modules?limit=10'));
          if (response.statusCode !== 200) {
            throw new Error("Unable to load popular modules");
          }
          modules = JSON.parse(response.body.toString());
          popular_modules = [];
          for (j = 0, len = modules.length; j < len; j++) {
            mod = modules[j];
            popular_modules.push(mod.identifier);
          }
          addModule = function() {
            var i, module_i, popular_module;
            console.log("Choose from popular modules or enter your own:".bold);
            for (i in popular_modules) {
              popular_module = popular_modules[i];
              module_i = parseInt(i) + 1;
              console.log(module_i + ") " + popular_module);
            }
            return prompt.get({
              properties: {
                module: {
                  description: 'Module (ex: 1, 2, readme.md)'
                }
              }
            }, function(err, module_result) {
              var export_name, k, len1, module_config, module_name;
              if (err) {
                return console.log("\nMaybe next time.");
              } else {
                if (module_result.module.length) {
                  if (!result.modules) {
                    result.modules = {};
                  }
                  if (module_result.module === '*') {
                    for (k = 0, len1 = popular_modules.length; k < len1; k++) {
                      module_name = popular_modules[k];
                      result.modules[module_name] = [];
                      response = request('get', crystal.url('api', "modules/" + module_name));
                      if (response.statusCode !== 200) {
                        throw new Error("Module does not exist in Crystal Hub (" + (crystal.url('hub')) + "): " + module_name);
                      }
                      module_config = JSON.parse(response.body.toString());
                      if (!module_config) {
                        throw new Error("Config not found for module (" + module_name + ")");
                      }
                      if (!module_config.exports) {
                        throw new Error("Module (" + module_name + ") has no exports");
                      }
                      for (export_name in module_config.exports) {
                        result.modules[module_name].push(export_name);
                      }
                    }
                    addModule(module_name);
                    return;
                  }
                  if (parseInt(module_result.module) > 0 && popular_modules[module_result.module - 1]) {
                    module_name = popular_modules[module_result.module - 1];
                  } else {
                    module_name = module_result.module;
                  }
                  if (result.modules[module_name]) {
                    console.log("Module (" + module_name + ") has already been added");
                  } else {
                    result.modules[module_name] = [];
                  }
                  return addImport(module_name);
                } else {
                  return initProject(crystal, result, opts.path);
                }
              }
            });
          };
          addImport = function(module_name) {
            var export_name, import_i, imports, module_config;
            console.log("Loading module...");
            response = request('get', crystal.url('api', "modules/" + module_name));
            if (response.statusCode !== 200) {
              throw new Error("Module does not exist in Crystal Hub (" + (crystal.url('hub')) + "): " + module_name);
            }
            module_config = JSON.parse(response.body.toString());
            if (!module_config) {
              throw new Error("Config not found for module (" + module_name + ")");
            }
            if (!module_config.exports) {
              throw new Error("Module (" + module_name + ") has no exports");
            }
            console.log("Choose exports from this module to import:".bold);
            imports = [];
            import_i = 1;
            for (export_name in module_config.exports) {
              if (result.modules[module_name].indexOf(export_name) !== -1) {
                continue;
              }
              console.log(import_i + ") " + export_name);
              imports.push(export_name);
              import_i++;
            }
            if (!imports.length) {
              console.log(("All exports have been imported from module (" + module_name + ")").blue);
              addModule();
              return;
            }
            return prompt.get({
              properties: {
                "import": {
                  description: 'Import (ex: 1, 2, etc.)'
                }
              }
            }, function(err, import_result) {
              if (err) {
                return console.log("\nMaybe next time.");
              } else {
                if (import_result["import"] === '*') {
                  for (import_i in imports) {
                    result.modules[module_name].push(imports[import_i]);
                  }
                  return addImport(module_name);
                } else if (import_result["import"].length) {
                  if (!imports[parseInt(import_result["import"]) - 1]) {
                    console.log(("Import (" + import_result["import"] + ") does not exit for module (" + module_name + ")").red);
                    addImport(module_name);
                    return;
                  }
                  result.modules[module_name].push(imports[parseInt(import_result["import"]) - 1]);
                  return addImport(module_name);
                } else {
                  return addModule();
                }
              }
            });
          };
          return addModule();
        }
      });
    }
  };

  module.exports = init;

}).call(this);
