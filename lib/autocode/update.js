// Generated by CoffeeScript 1.10.0
(function() {
  var autocode, error, fs, gunzip, mkdirp, request, semver, tarfs, untar, update, userHome, version, zlib;

  autocode = require('../autocode');

  error = require('../error');

  fs = require('fs');

  gunzip = require('gunzip-maybe');

  mkdirp = require('mkdirp');

  request = require('sync-request');

  semver = require('semver');

  tarfs = require('tar-fs');

  untar = require('untar.js');

  userHome = require('user-home');

  version = require('../version');

  zlib = require('zlib');

  update = function() {
    var config, j, len, loadModules, loaded_modules, modules, path, project, submodule, submodules;
    path = userHome + "/.autocode/module/";
    if (!fs.existsSync(path)) {
      mkdirp.sync(path);
    }
    if (this.config) {
      config = this.config;
    } else {
      config = this.load();
    }
    if (config.modules || config.imports) {
      modules = config.modules ? config.modules : config.imports;
    }
    if (!modules) {
      return;
    }
    loaded_modules = {};
    submodules = [];
    loadModules = function(modules) {
      var access_token_url, data, headers, j, len, module_config, module_name, module_path, module_path_name, module_version, module_version_query, release, releases, resp, response, results, tarball_url, url;
      results = [];
      for (module_name in modules) {
        module_version = null;
        module_version_query = modules[module_name];
        module_path_name = module_name.replace(/\./, '/');
        if (!loaded_modules[module_name]) {
          loaded_modules[module_name] = [];
        }
        if (loaded_modules[module_name].indexOf(module_version_query) !== -1) {
          continue;
        } else {
          loaded_modules[module_name].push(module_version_query);
        }
        if (module_version_query.match(/^(\.|\/)/)) {
          module_path = module_version_query;
          module_config = new autocode(module_path).config;
          if (module_config.imports) {
            loadModules(module_config.imports);
          } else {
            loadModules(module_config.modules);
          }
          continue;
        }
        console.log("\n" + ' UPDATE '.bgBlue.white + (" " + module_name + " " + module_version_query + " ").bgWhite.black);
        headers = {
          'User-Agent': 'Crystal Autocode <support@autocode.run> (https://autocode.run/autocode)'
        };
        access_token_url = '';
        if (process.env.GITHUB_ACCESS_TOKEN) {
          access_token_url += "?access_token=" + process.env.GITHUB_ACCESS_TOKEN;
        }
        if (module_version_query === 'latest') {
          url = "https://api.github.com/repos/" + module_name + "/releases/latest" + access_token_url;
        } else {
          url = "https://api.github.com/repos/" + module_name + "/releases" + access_token_url;
        }
        resp = request('get', url, {
          headers: headers,
          allowRedirectHeaders: ['User-Agent']
        });
        if (resp.statusCode !== 200) {
          throw new Error("Module (" + module_name + ") does not exist in the Crystal Hub.");
        }
        if (module_version_query === 'latest') {
          release = JSON.parse(resp.body.toString());
          module_version = semver.clean(release.tag_name);
          tarball_url = release.tarball_url;
        } else {
          releases = JSON.parse(resp.body.toString());
          if (!releases[0]) {
            throw new Error("Repository not found for module: " + module_name);
          }
          for (j = 0, len = releases.length; j < len; j++) {
            release = releases[j];
            if (semver.satisfies(release.tag_name, module_version_query)) {
              module_version = semver.clean(release.tag_name);
              tarball_url = release.tarball_url;
              break;
            }
          }
          if (!module_version) {
            throw new Error("No matches for Module (" + module_name + ") with version (" + module_version_query + ")");
          }
        }
        console.log(' DOWNLOAD '.bgGreen.white + (" " + module_version + " ").bgWhite.black);
        module_path = "" + path + config.host + "/" + module_path_name + "/" + module_version;
        url = "" + tarball_url + access_token_url;
        response = request('get', url, {
          headers: headers,
          allowRedirectHeaders: ['User-Agent']
        });
        data = zlib.gunzipSync(response.body);
        untar.untar(data).forEach(function(file) {
          var buffer, file_path, filename, i, link_path;
          filename = file.filename.split('/').slice(1).join('/');
          file_path = require('path').dirname(filename);
          mkdirp.sync(module_path + "/" + file_path);
          buffer = new Buffer(file.fileData.length);
          i = 0;
          while (i < file.fileData.length) {
            buffer.writeUInt8(file.fileData[i], i);
            i++;
          }
          fs.writeFileSync(module_path + "/" + filename, buffer);
          if (module_version_query === 'latest') {
            link_path = "" + path + config.host + "/" + module_path_name + "/latest";
            if (fs.existsSync(link_path)) {
              fs.unlinkSync(link_path);
            }
            return fs.symlinkSync(module_path, link_path);
          }
        });
        submodules.push(module_path);
        module_config = new autocode(module_path).config;
        if (module_config.imports) {
          results.push(loadModules(module_config.imports));
        } else {
          results.push(loadModules(module_config.modules));
        }
      }
      return results;
    };
    loadModules(modules);
    for (j = 0, len = submodules.length; j < len; j++) {
      submodule = submodules[j];
      project = new autocode(submodule);
      project.build({
        skipGeneration: true
      });
    }
    return console.log("\n" + ' DONE! '.bgGreen.white);
  };

  module.exports = update;

}).call(this);
