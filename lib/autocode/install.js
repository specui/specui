// Generated by CoffeeScript 1.10.0
(function() {
  var autocode, fs, install, mkdirp, path, request, semver, untar, userHome, zlib;

  autocode = require('../autocode');

  fs = require('fs');

  mkdirp = require('mkdirp');

  path = require('path');

  request = require('sync-request');

  semver = require('semver');

  untar = require('untar.js');

  userHome = require('user-home');

  zlib = require('zlib');

  install = function(opts) {
    var access_token_url, config_resp, config_url, headers, host, j, len, module_is_lastest, module_name, module_parse, module_path, module_version, project, release, release_i, release_resp, release_url, release_version, releases, tag_name, tarball, tarball_response, tarball_url;
    host = 'github.com';
    if (typeof opts === 'object' && opts.name) {
      module_name = opts.name;
    }
    if (typeof opts === 'object' && opts.version) {
      module_version = opts.version;
    } else if (module_name.match('@')) {
      module_parse = module_name.split('@');
      module_name = module_parse[0];
      module_version = module_parse[1];
    } else {
      module_version = 'latest';
    }
    if (!module_name) {
      throw new Error("Module Name is required for `autocode install`.");
    }
    console.log(("Loading module (" + module_name + ")...").blue);
    headers = {
      'User-Agent': 'Autocode <support@autocode.run> (https://autocode.run/autocode)'
    };
    access_token_url = '';
    if (process.env.GITHUB_ACCESS_TOKEN) {
      access_token_url += "?access_token=" + process.env.GITHUB_ACCESS_TOKEN;
    }
    if (module_version === 'latest') {
      module_is_lastest = true;
      release_url = "https://api.github.com/repos/" + module_name + "/releases/latest" + access_token_url;
      release_resp = request('get', release_url, {
        headers: headers,
        allowRedirectHeaders: ['User-Agent']
      });
      if (release_resp.statusCode !== 200) {
        throw new Error("Module (" + module_name + ") does not exist on GitHub.");
      }
      release = JSON.parse(release_resp.body);
      if (!release) {
        throw new Error("Unable to locate generator (" + name + ").");
      }
      module_version = semver.clean(release.tag_name);
      tag_name = release.tag_name;
      console.log(("Latest version is " + release.tag_name + ".").green);
    } else {
      module_is_lastest = false;
      release_url = "https://api.github.com/repos/" + module_name + "/releases" + access_token_url;
      release_resp = request('get', release_url, {
        headers: headers,
        allowRedirectHeaders: ['User-Agent']
      });
      if (release_resp.statusCode !== 200) {
        throw new Error("Module (" + module_name + ") does not exist on GitHub.");
      }
      releases = JSON.parse(release_resp.body);
      if (!releases) {
        throw new Error("Unable to locate generator (" + name + ").");
      }
      release_i = 0;
      for (j = 0, len = releases.length; j < len; j++) {
        release = releases[j];
        release_version = semver.clean(release.tag_name);
        if (semver.satisfies(release_version, module_version)) {
          if (release_i === 0) {
            module_is_lastest = true;
          }
          module_version = semver.clean(release.tag_name);
          tag_name = release.tag_name;
          break;
        }
        release_i++;
      }
      if (!tag_name) {
        throw new Error("Unable to find version (" + module_version + ") for module (" + module_name + ").");
      }
      console.log(("Found version (" + module_version + ") with tag (" + tag_name + ").").green);
    }
    if (opts.force !== true) {
      config_url = "https://api.github.com/repos/" + module_name + "/contents/.autocode/config.yml" + access_token_url + "&ref=" + tag_name;
      config_resp = request('get', config_url, {
        headers: headers,
        allowRedirectHeaders: ['User-Agent']
      });
      if (config_resp.statusCode !== 200) {
        throw new Error("Module (" + module_name + ") has not implemented Autocode. Use -f to install anyways.");
      }
    }
    tarball_url = release.tarball_url;
    console.log(("Downloading from: " + tarball_url).bold);
    tarball_url += access_token_url;
    tarball_response = request('get', tarball_url, {
      headers: headers,
      allowRedirectHeaders: ['User-Agent']
    });
    if (tarball_response.statusCode !== 200) {
      throw new Error("Unable to download module (" + module_name + ").");
    }
    tarball = zlib.gunzipSync(tarball_response.body);
    if (!tarball) {
      throw new Error("Unable to unzip module (" + module_name + ").");
    }
    module_path = path.normalize(userHome + "/.autocode/module/" + host + "/" + module_name + "/" + module_version);
    if (fs.existsSync(module_path) && opts.ignoreOverwrite) {
      return {
        name: module_name,
        version: module_version
      };
    }
    untar.untar(tarball).forEach(function(file) {
      var buffer, file_path, filename, i, link_path;
      filename = file.filename.split('/').slice(1).join('/');
      file_path = path.dirname(filename);
      mkdirp.sync(module_path + "/" + file_path);
      buffer = new Buffer(file.fileData.length);
      i = 0;
      while (i < file.fileData.length) {
        buffer.writeUInt8(file.fileData[i], i);
        i++;
      }
      fs.writeFileSync(module_path + "/" + filename, buffer);
      if (module_is_lastest) {
        link_path = path.normalize(userHome + "/.autocode/module/" + host + "/" + module_name + "/latest");
        if (fs.existsSync(link_path)) {
          fs.unlinkSync(link_path);
        }
        return fs.symlinkSync(module_path, link_path);
      }
    });
    project = new autocode(module_path);
    project.update();
    project.build({
      skipGeneration: true
    });
    console.log(("Successfully installed " + module_name + " at: " + module_path).green);
    return {
      name: module_name,
      version: module_version
    };
  };

  module.exports = install;

}).call(this);
